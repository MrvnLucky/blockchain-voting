// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract Voting {
    // Admin address
    address private admin;

    // Voting status
    bool private isVotingRunning;

    // Candidates data
    struct Candidate {
        uint256 id;
        string name;
        uint256 voteCount;
        bool isActive;
    }

    mapping(uint256 => Candidate) private candidates;
    uint256 private candidatesCount;

    struct CandidateWithoutVote {
        uint256 id;
        string name;
    }

    struct Voter {
        bool isVoted;
        uint256 candidateId;
    }

    // Voters data
    mapping(address => Voter) private voters;
    address[] private voterAddresses;

    // Constructor
    constructor() {
        admin = msg.sender;
        isVotingRunning = false;
        candidatesCount = 0;
    }

    // Modifiers
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can call this function.");
        _;
    }

    modifier onlyVotingRunning() {
        require(isVotingRunning == true, "Voting is not running.");
        _;
    }

    modifier onlyVotingStopped() {
        require(isVotingRunning == false, "Voting is still running");
        _;
    }

    modifier onlyAllowedAddress() {
        bool isAllowed = false;
        for (uint256 i = 0; i < voterAddresses.length; i++) {
            if (voterAddresses[i] == msg.sender) {
                isAllowed = true;
                break;
            }
        }
        require(isAllowed, "Address not allowed");
        _;
    }

    modifier onlyVoter() {
        require(voters[msg.sender].isVoted == false, "You have already voted.");
        _;
    }

    // Events
    event CandidateAdded(uint256 id, string name, bool isActive);
    event CandidateRemoved(uint256 id);
    event CandidateNameUpdated(uint256 id, string name);
    event VotingStarted();
    event VotingStopped();
    event VoteCasted(address voter, uint256 id);
    event CandidateDeactive(uint256 id);

    // Admin functions
    function addCandidate(string memory _name) public onlyAdmin {
        require(bytes(_name).length > 0, "Candidate name should not be empty.");
        candidatesCount++;
        candidates[candidatesCount] = Candidate(
            candidatesCount,
            _name,
            0,
            true
        );

        emit CandidateAdded(candidatesCount, _name, true);
    }

    function removeCandidate(uint256 _id) public onlyAdmin {
        require(_id > 0 && _id <= candidatesCount, "Invalid candidate ID.");
        delete candidates[_id];
        emit CandidateRemoved(_id);
    }

    function deativateCandidate(uint256 _id) public onlyAdmin {
        require(_id > 0 && _id <= candidatesCount, "Invalid candidate ID.");
        candidates[_id].isActive = false;
        emit CandidateDeactive(_id);
    }

    function updateCandidateName(
        uint256 _id,
        string memory _name
    ) public onlyAdmin {
        require(_id > 0 && _id <= candidatesCount, "Invalid candidate ID.");
        require(bytes(_name).length > 0, "Candidate name should not be empty.");

        candidates[_id].name = _name;

        emit CandidateNameUpdated(_id, _name);
    }

    function startVoting() public onlyAdmin {
        require(isVotingRunning == false, "Voting is already running.");

        isVotingRunning = true;

        emit VotingStarted();
    }

    function stopVoting() public onlyAdmin {
        require(isVotingRunning == true, "Voting has not started.");

        isVotingRunning = false;

        emit VotingStopped();
    }

    // function addVoter(address _voterAddress) public {
    //     voters[_voterAddress] = Voter(false, 0);
    //     voterAddresses.push(_voterAddress);
    // }

    function addVoter(address _voterAddress) public {
        voters[_voterAddress] = Voter(false, 0);
        voterAddresses.push(_voterAddress);
    }

    function removeVoter(address _voterAddress) public {
        delete voters[_voterAddress];
        for (uint256 i = 0; i < voterAddresses.length; i++) {
            if (voterAddresses[i] == _voterAddress) {
                voterAddresses[i] = voterAddresses[voterAddresses.length - 1];
                voterAddresses.pop();
                break;
            }
        }
    }

    function getOneVoter(
        address _voterAddress
    ) public view returns (bool, uint256) {
        return (
            voters[_voterAddress].isVoted,
            voters[_voterAddress].candidateId
        );
    }

    function getAllVoter() public view returns (address[] memory) {
        return voterAddresses;
    }

    // Function to get all voters
    // function getAllVoters() public view returns (Voter[] memory) {
    //     Voter[] memory allVoters = new Voter[](voterAddresses.length);
    //     for (uint256 i = 0; i < voterAddresses.length; i++) {
    //         allVoters[i] = voters[voterAddresses[i]];
    //     }
    //     return allVoters;
    // }

    // Voter functions
    function castVote(
        uint256 _id
    ) public onlyVotingRunning onlyVoter onlyAllowedAddress {
        require(_id > 0 && _id <= candidatesCount, "Invalid candidate ID.");

        voters[msg.sender].isVoted = true;
        candidates[_id].voteCount++;
        voters[msg.sender].candidateId = _id;

        emit VoteCasted(msg.sender, _id);
    }

    // Getters
    function getOneCandidateWithoutVotes(
        uint256 _id
    ) public view returns (uint256, string memory) {
        require(_id > 0 && _id <= candidatesCount, "Invalid candidate ID.");
        Candidate memory candidate = candidates[_id];
        return (candidate.id, candidate.name);
    }

    function getOneCandidate(
        uint256 _id
    ) public view returns (uint256, string memory, uint256) {
        require(_id > 0 && _id <= candidatesCount, "Invalid candidate ID.");
        Candidate memory candidate = candidates[_id];
        return (candidate.id, candidate.name, candidate.voteCount);
    }

    function getAllCandidatesWithoutVotes()
        public
        view
        returns (CandidateWithoutVote[] memory)
    {
        CandidateWithoutVote[]
            memory allCandidates = new CandidateWithoutVote[](candidatesCount);
        for (uint256 i = 1; i <= candidatesCount; i++) {
            allCandidates[i - 1] = CandidateWithoutVote(
                candidates[i].id,
                candidates[i].name
            );
        }
        return allCandidates;
    }

    function getAllCandidates()
        public
        view
        onlyVotingStopped
        returns (Candidate[] memory)
    {
        Candidate[] memory allCandidates = new Candidate[](candidatesCount);
        for (uint256 i = 1; i <= candidatesCount; i++) {
            allCandidates[i - 1] = candidates[i];
        }
        return allCandidates;
    }

    // Function to get all candidates with isActive = true
    function getAllActiveCandidates() public view returns (Candidate[] memory) {
        uint256 activeCandidateCount = 0;
        for (uint256 i = 1; i <= candidatesCount; i++) {
            if (candidates[i].isActive) {
                activeCandidateCount++;
            }
        }

        Candidate[] memory activeCandidates = new Candidate[](
            activeCandidateCount
        );
        uint256 currentIndex = 0;
        for (uint256 i = 1; i <= candidatesCount; i++) {
            if (candidates[i].isActive) {
                activeCandidates[currentIndex] = candidates[i];
                currentIndex++;
            }
        }
        return activeCandidates;
    }

    // Function to get all candidates with isActive = true
    function getAllActiveCandidatesWithoutVote()
        public
        view
        returns (CandidateWithoutVote[] memory)
    {
        uint256 activeCandidateCount = 0;
        for (uint256 i = 1; i <= candidatesCount; i++) {
            if (candidates[i].isActive) {
                activeCandidateCount++;
            }
        }
        CandidateWithoutVote[]
            memory activeCandidates = new CandidateWithoutVote[](
                activeCandidateCount
            );
        uint256 currentIndex = 0;
        for (uint256 i = 1; i <= candidatesCount; i++) {
            if (candidates[i].isActive) {
                activeCandidates[currentIndex] = CandidateWithoutVote(
                    candidates[i].id,
                    candidates[i].name
                );
                currentIndex++;
            }
        }
        return activeCandidates;
    }

    // function removeVoter(address _voterAddress) public {
    //     delete voters[_voterAddress];
    // }

    function countCandidates() public view returns (uint256) {
        return candidatesCount;
    }

    function getVotingStatus() public view returns (bool) {
        return isVotingRunning;
    }
}
